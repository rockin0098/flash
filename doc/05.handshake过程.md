### handshake握手过程

*参考https://core.telegram.org/mtproto/auth_key*

#### handshake 消息
握手消息是未加密消息, 完成握手之前还没有生成对应的 auth_key , 所以握手的目标就是成功生成auth_key

握手消息包含以下三个请求

1. req_pq ==> resPQ
2. req_DH_params ==> server_DH_params_ok
3. set_client_DH_params ==> dhGenOk


#### req_pq

```
req_pq#60469778 nonce:int128 = ResPQ;
```

请求中带一个客户端随机生成的 nonce

```
resPQ#05162463 nonce:int128 server_nonce:int128 pq:string server_public_key_fingerprints:Vector long = ResPQ;
```

对于正确的返回消息其中必须包含
```nonce``` 客户端请求中的nonce
```server_nonce``` 服务端随机生成的nonce
```pq``` 两个质数的乘积, pq一般小于 2^63-1
```server_public_key_fingerprints``` 服务端证书指纹

#### req_DH_params

```
req_DH_params#d712e4be nonce:int128 server_nonce:int128 p:string q:string public_key_fingerprint:long encrypted_data:string = Server_DH_Params
```

```nonce``````server_nonce``````p``````q``````public_key_fingerprint``` 这些字段反填服务端 reqPQ 中的返回值, 其中p,q由客户端做pq乘积的因式分解而来，其中 p < q 

```encrypted_data``` 服务端用私钥解密，得到明文，其结构为 sha+len+```p_q_inner_data```
sha 为hash值 20字节
len 为TL Object长度字段

```
p_q_inner_data#83c95aec pq:string p:string q:string nonce:int128 server_nonce:int128 new_nonce:int256 = P_Q_inner_data;
```

pq,p,q,nonce,server_nonce 可以和请求消息中的值进行互相校验
服务端保存 new_nonce

之后进行DH密钥交换算法计算
1. 生成随机数 A 256bit
2. 生成质数P 2048bit
3. 生成质数G 
3. 计算 G^A

























